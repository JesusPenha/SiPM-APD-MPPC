# Module for testing Silicon Photo-Multipliers and Multi-Pixel Photon Counters. This python module allows users to performe noise analysis of SiPM/MPPCs: Dark Count Rate, Afterpulsing, and Crosstalk. Futhermore, the SiPM/MPPC module is capable to set SiPM arrays (MPPC) for large area detectors like Ring Imaging Cherenkov, Cherenkov Telescopes, etc. Users can simulate ring or trace shape signals based on the expected number of photons generated by the source. The estimation of the signal to noise ratios (SNR) is also available.

# Author: Dr. Jesus Pena Rodriguez
# Experiment: Compressed Baryonic Matter (CBM)
# Bergische Universit√§t Wuppertal
# March, 2023

import numpy as np
import matplotlib.pylab as plt
from scipy.optimize import curve_fit
import matplotlib

def DCR_model(t, Tau):
    return np.exp(-t/Tau)

# Pulse shape simulation

def Pulse(Rt, Ft, A, tm, R, plot=False):

    # Pulse shape
    
    Pw = Ft*10/1e-9 # Pulse window (ns)
    S = int(Pw/R)

    t_pulse = np.linspace(0,Pw,S)*1e-9
    N = len(t_pulse)
    Pulse_shape = np.zeros(N)


    for i in range (N):
        if t_pulse[i] < tm:
            Pulse_shape[i] = A*(1-np.exp(-t_pulse[i]/Rt))
            B = Pulse_shape[i]
        else:
            Pulse_shape[i] = B*np.exp((tm-t_pulse[i])/Ft)
            
    if plot== True:
        plt.figure(figsize=(8, 6))
        plt.plot(t_pulse*1e9, Pulse_shape, 'k')
        plt.xlabel("Time [ns]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel('Amplitude', horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=12)
        plt.yticks(fontsize=12)

        plt.savefig('Figures/Pulse_shape.eps', format='eps', bbox_inches='tight', pad_inches=0)

        plt.show()
        
    return Pulse_shape/np.max(Pulse_shape)


# SiPM (Pixel) simulation

def Pixel (Pulse_shape, DCR, Pixel_size, Cross,  After, W, R, sigma, plot=False): # DCR(Hz/mm2), pixel size(mm2), Crosstalk(%), Afterpulsing(%), recording window(ns)

    N = len(Pulse_shape)

    DCR_pixel = DCR*Pixel_size
    Tau = 1/DCR_pixel
    F_after = 100*DCR_pixel
    Tau_after = 1/F_after

    # Noise generation
    
    L = int(W/R)
    time = np.linspace(0,W,L)
    DCR_impulses = np.zeros(L)
    Cross_impulses = np.zeros(L)
    After_impulses = np.zeros(L)
    DCR_Cross_After_pulses = np.zeros(L)
    index = 0

    alpha = 2.2 - 0.02*Cross*100
    
    while index < L-N:
        Rt = np.random.exponential(scale=Tau, size=None)*1e9
        index = index + int(Rt/R)
        if index >= L-N:
            break

        if np.random.uniform() < Cross: # Crosstalk probability
            Cross_impulses[index] = 2
            if np.random.uniform() < Cross: # 3 pe crosstalk
                if np.random.uniform() < alpha*Cross: # 4 pe crosstalk
                    if np.random.uniform() < alpha*Cross: # 5 pe crosstalk
                        if np.random.uniform() < alpha*Cross: # 6 pe crosstalk
                            if np.random.uniform() < alpha*Cross: # 7 pe crosstalk
                                if np.random.uniform() < alpha*Cross: # 8 pe crosstalk
                                    DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(8, sigma)
                                else:
                                    DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(7, sigma)
                            else:
                                DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(6, sigma)
                        else : 
                            DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(5, sigma)
                    else:
                        DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(4, sigma)
                else:
                    DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(3, sigma)

            else: # 2 pe crosstalk
                DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(2, sigma)
        
        else:
            DCR_impulses[index] = 1
            DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(1, sigma)

        if np.random.uniform() < After: # Afterpulse probability
            C = 0
            while C < 0.5: # Force the afterpulse amplitude to be greater than 0.5 spe
                Rt_after = int(np.random.exponential(scale=Tau_after, size=None)*1e9/R)
                C = 1-np.exp(-(Rt_after*R*1e-9)/Tau_after)
            
            if index+Rt_after > L-N:
                break
            After_impulses[index+Rt_after] = 1
            DCR_Cross_After_pulses[index+Rt_after:index+Rt_after+N] = DCR_Cross_After_pulses[index+Rt_after:index+Rt_after+N] + C*np.random.normal(1, sigma)*Pulse_shape

    if plot == True:
        plt.figure(figsize=(18, 4))
        plt.plot(time, DCR_Cross_After_pulses, 'k')
        plt.xlabel("Time [ns]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Amplitude [spe]", horizontalalignment='right', y=1.0, fontsize=15)

    return DCR_Cross_After_pulses, time


# MPPC noise simulation

def MPPC(Pulse_shape, N_pixel, DCR, Pixel_size, Cross, After, W, R, sigma):
    
    L = int(W/R)
    Channels = np.zeros((N_pixel,L))

    for i in range(N_pixel):
        Channels[i,:], time = Pixel(Pulse_shape, DCR, Pixel_size, Cross, After, W, R, sigma)
        
    return Channels, time


# Amplitude and Inter-time information

def Amplitude_Intertime(Channels, N_pixel, W, R, plot=False):

    L = int(W/R)
    Amplitude = []
    Inter_time = []
    t0 = 0

    if N_pixel > 1:
        for i in range(N_pixel):
            for j in range(L):
                if Channels[i,j] > Channels[i,j-1] and Channels[i,j] > Channels[i,j+1]:
                    Amplitude.append(Channels[i,j])
                    Inter_time.append(j*R*1e-9 - t0)
                    t0 = j*R*1e-9
            t0 = 0
    else:
        for j in range(L):
            if Channels[j] > Channels[j-1] and Channels[j] > Channels[j+1]:
                Amplitude.append(Channels[j])
                Inter_time.append(j*R*1e-9 - t0)
                t0 = j*R*1e-9
        t0 = 0
        
    if plot==True:
        
        plt.figure(figsize=(8, 6))
        plt.semilogx(Inter_time, Amplitude, ls=' ', marker='o', color='seagreen', alpha=0.2)
        plt.xlabel("Inter-time [s]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Amplitude [spe]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
        bins, edges = np.histogram(np.log10(np.array(Inter_time)),50)
        left, right = edges[:-1], edges[1:]
        X = np.array([left, right]).T.flatten()
        Y = np.array([bins, bins]).T.flatten()

        plt.figure(figsize=(8, 6))
        plt.loglog(10**X, Y,'b')
        plt.xlabel("Inter-time [s]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Counts", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
        bins, edges = np.histogram(Amplitude,295)
        left, right = edges[:-1], edges[1:]
        X = np.array([left, right]).T.flatten()
        Y = np.array([bins, bins]).T.flatten()

        plt.figure(figsize=(8, 6))
        plt.semilogy(X, Y,'k')
        plt.xlabel("Amplitude [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Counts", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
    return Amplitude, Inter_time, X, Y

# DCR vs. threshold

def DCR_threshold(Channel, W, R, Lt, Ht, samples, plot=False):
    
    Threshold = np.linspace(Lt,Ht,samples)
    M = len(Threshold)
    DCR_MPPC = np.zeros(M)
    count = 0
    L = int(W/R)

    for i in range(M):
        for j in range(L):
            if Channel[j]>= Threshold[i] and Channel[j] > Channel[j-1] and Channel[j] > Channel[j+1]:
                count += 1
        DCR_MPPC[i]=count/(W*1e-9)
        count = 0
        
    if plot==True:
        plt.figure(figsize=(8, 6))
        plt.semilogy(Threshold, DCR_MPPC, 'k', label='model')
        plt.xlabel("Threshold [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("DCR [Hz]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.axvline(0.5, color='r')
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.grid()
        plt.show()

    return DCR_MPPC, Threshold

# DCR vs. threshold

def DCR_threshold_data(Channel, W, R, Threshold, plot=False):
    
    M = len(Threshold)
    DCR_MPPC = np.zeros(M)
    count = 0
    L = int(W/R)

    for i in range(M):
        for j in range(L):
            if Channel[j]>= Threshold[i] and Channel[j] > Channel[j-1] and Channel[j] > Channel[j+1]:
                count += 1
        DCR_MPPC[i]=count/(W*1e-9)
        count = 0
        
    if plot==True:
        plt.figure(figsize=(8, 6))
        plt.semilogy(Threshold, DCR_MPPC, 'k', label='model')
        plt.xlabel("Threshold [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("DCR [Hz]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.axvline(0.5, color='r')
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.grid()
        plt.show()

    return DCR_MPPC, Threshold

def Camera_noise(Pulse_shape, N_pixel, Pixel_size, M, DCR, Cross, After, W, R, sigma, Nr, Nc, t0, Window, Th ):

    Array_i = np.zeros((N_pixel,W))
    P = Nr*Nc # Number of MPPC (rows x columns)

    Noise_array = np.zeros((Nr*M,Nc*M))

    fig = plt.figure(figsize=(5, 5))

    C = 0
    F = 0

    # Triggering parameters

    Trigger = Th*np.max(Pulse_shape)

    A = Nc if Nc>Nr else Nr
    fig = plt.figure(figsize=(A,A))
    
    for j in range(P):
        Array_i, time = MPPC(Pulse_shape, N_pixel, DCR, Pixel_size, Cross, After, W, R, sigma)

        MPPC_i = np.zeros(N_pixel) 

        for i in range(N_pixel):
            if np.max(Array_i[i,t0:t0+Window]) >= Trigger:
                MPPC_i[i] = 1
        MPPC_data = np.reshape(MPPC_i, (M, M))
        Noise_array[F*M+0:F*M+M,C*M+0:C*M+M] = MPPC_data 
        C+=1
        if C==P/Nr:
            C=0
            F+=1

        plt.subplot(A,A,j+1)
        plt.imshow(MPPC_data, cmap='Blues')
        plt.xticks([])
        plt.yticks([])
        fig.tight_layout(pad=0.01)
        
    return Noise_array


def Ring_generator(Nr, Nc, r, M, Np_ring, N_rings):

    Ring_array = np.zeros((Nc*M,Nr*M))

    for j in range(N_rings):

        x0 = int(np.random.uniform(0, Nc*M))
        y0 = int(np.random.uniform(0, Nr*M))

        for i in range(Np_ring):

            theta = np.random.uniform(0, 2*np.pi)

            x = int(r*np.cos(theta))
            y = int(r*np.sin(theta))
            a = x + x0
            b = y + y0

            if a >= 0 and b >=0 and a < Nc*M and b < Nr*M: # boundary conditions
                Ring_array[a,b]= Ring_array[a,b] + 1
                
    return Ring_array


def Shower_generator(Nr, Nc, M, Np_shower, cov):
    
    Shower_array = np.zeros((Nc*M,Nr*M))
    
    x0 = int(np.random.uniform(0, Nc*M))
    y0 = int(np.random.uniform(0, Nr*M))
    
    pts = np.random.multivariate_normal([x0, y0], cov, Np_shower)
    
    for i in range(Np_shower):
    
            a = int(pts[i, 0])
            b = int(pts[i, 1])
    
            if a >= 0 and b >=0 and a < Nc*M and b < Nr*M: # boundary conditions
                Shower_array[a,b]= Shower_array[a,b] + 1
                
    return Shower_array
    

def Camera_plot(signal, noise, M, Nr, Nc, cmap='viridis', lc='w'):
    Event =  signal.T + noise
    
    plt.imshow(Event, cmap=cmap)
    
    for i in range(Nc):
            plt.axvline((i)*M-0.5, color=lc, lw=0.5, ls='dotted')
    for i in range(Nr):
            plt.axhline((i)*M-0.5, color=lc, lw=0.5, ls='dotted')
    
    plt.xticks([])
    plt.yticks([])
    
    plt.colorbar(label='Photoelectrons')

def voting_trigger(signal, noise, M, Nr, Nc, L0_threshold, cmap='viridis'):

    Event =  signal.T + noise

    L0_trigger = np.zeros((Nr, Nc))
    
    for i in range(Nr):
        for j in range(Nc):
            if np.sum(Event[i*M:i*M+M,j*M:j*M+M]) > L0_threshold:
                L0_trigger[i,j] = 1

    plt.imshow(L0_trigger, cmap=cmap)
    plt.title("L0 trigger", fontsize=15)
    plt.xticks([])
    plt.yticks([])

    return L0_trigger