# Module for testing Silicon Photo-Multipliers and Multi-Pixel Photon Counters. This python module allows users to performe noise analysis of SiPM/MPPCs: Dark Count Rate, Afterpulsing, and Crosstalk. Futhermore, the SiPM/MPPC module is capable to set SiPM arrays  for large area detectors like Ring Imaging Cherenkov, Cherenkov Telescopes, etc. Users can simulate ring or trace shape signals based on the expected number of photons generated by the source. The estimation of the signal to noise ratios (SNR) is also available.

# Author: Dr. Jesus Pena Rodriguez
# Experiment: Compressed Baryonic Matter (CBM)
# Bergische Universit√§t Wuppertal
# March, 2023

import numpy as np
import matplotlib.pylab as plt
from scipy.optimize import curve_fit
import matplotlib

# DCR distribution

def DCR_model(t, Tau):
    return np.exp(-t/Tau)

# Afterpulse distribution

np.random.seed(523)

def AP_pdf(x, Tau_rec, Tau_AP):
    
    A = (Tau_rec + Tau_AP)/Tau_AP**2
    f_AP = A*(1- np.exp(-x/Tau_rec))*np.exp(-x/Tau_AP)
    
    return f_AP

def AP_gen(n, Tau_rec, Tau_AP):
    i = 0
    output = np.zeros(n)
    t = np.linspace(0,500,300)*1e-9
    c = np.max(AP_pdf(t, Tau_rec, Tau_AP))
    
    while i < n:
        U = np.random.uniform(size = 1)
        V = 300e-9*np.random.uniform(size = 1)
        if U < 1/c * AP_pdf(V, Tau_rec, Tau_AP):
            output[i] = V
            i = i + 1
    return output
    
# Pulse shape simulation

def Pulse(Rt, Ft, A, R, plot=False):

    # Pulse shape
    Pw = Ft*10/1e-9 # Pulse window (ns)
    S = int(Pw/R)

    t_pulse = np.linspace(0,Pw,S)*1e-9
    N = len(t_pulse)
    Pulse_shape = np.zeros(N)

    for i in range (N):

        Pulse_shape[i] =(1-np.exp(-t_pulse[i]/Rt))*np.exp((-t_pulse[i])/Ft)

    Pulse_shape =  A*Pulse_shape/np.max(Pulse_shape)
            
    if plot== True:
        plt.figure(figsize=(6,4))
        plt.plot(t_pulse*1e9, Pulse_shape, 'k')
        plt.xlabel("Time [ns]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel('Amplitude', horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=12)
        plt.yticks(fontsize=12)

        plt.savefig('Figures/Pulse_shape.eps', format='eps', bbox_inches='tight', pad_inches=0)

        plt.show()
        
    return Pulse_shape


# SiPM (Pixel) simulation

def Pixel (Pulse_shape, DCR, Pixel_size, Cross,  After, Tau_rec, Tau_AP, W, R,  sigma, plot=False): # DCR(Hz/mm2), pixel size(mm2), Crosstalk(%), Afterpulsing(%), recording window(ns)
       
    N = len(Pulse_shape)

    DCR_pixel = DCR*Pixel_size
    Tau = 1/DCR_pixel

    # Noise generation
    
    L = int(W/R)
    time = np.linspace(0,W,L)
    DCR_impulses = np.zeros(L)
    Cross_impulses = np.zeros(L)
    After_impulses = np.zeros(L)
    DCR_Cross_After_pulses = np.zeros(L)
    index = 0

    Nc = 10 # Number of crosstalk pe 
    
    # Crosstalk
    alpha = 2.2 - 0.02*Cross*100
    
    while index < L-N:
        Rt = np.random.exponential(scale=Tau, size=None)*1e9
        index = index + int(Rt/R)
        if index >= L-N:
            break

        if np.random.uniform() < Cross: # Crosstalk probability
            Cross_impulses[index] = 2
            if np.random.uniform() < Cross: # > 3 pe crosstalk
                for n in (np.linspace(1,Nc,Nc)): 
                    if np.random.uniform() > alpha*Cross:
                        DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(n+2, sigma)
                        break
            else: # 2 pe crosstalk
                DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(2, sigma)
        
        else:
            DCR_impulses[index] = 1
            DCR_Cross_After_pulses[index:index+N] = DCR_Cross_After_pulses[index:index+N] + Pulse_shape*np.random.normal(1, sigma)

        if np.random.uniform() < After: # Afterpulse probability
            
            Rt_after = int(AP_gen(1, Tau_rec, Tau_AP)*1e9/R)
            
            C = 1-np.exp(-(Rt_after*R*1e-9)/Tau_rec)
            
            if index+Rt_after > L-N:
                break
            After_impulses[index+Rt_after] = 1
            DCR_Cross_After_pulses[index+Rt_after:index+Rt_after+N] = DCR_Cross_After_pulses[index+Rt_after:index+Rt_after+N] + np.random.normal(C, sigma)*Pulse_shape

    if plot == True:
        plt.figure(figsize=(18, 4))
        plt.plot(time, DCR_Cross_After_pulses, 'k')
        plt.xlabel("Time [ns]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Amplitude [spe]", horizontalalignment='right', y=1.0, fontsize=15)

    return DCR_Cross_After_pulses, time


# MPPC noise simulation

def MPPC(Pulse_shape, N_pixel, DCR, Pixel_size, Cross, After, Tau_rec, Tau_AP, W, R, sigma):
    
    L = int(W/R)
    Channels = np.zeros((N_pixel,L))

    for i in range(N_pixel):
        Channels[i,:], time = Pixel(Pulse_shape, DCR, Pixel_size, Cross, After, Tau_rec, Tau_AP, W, R, sigma)
        
    return Channels, time


# Amplitude and Inter-time information

def Amplitude_Intertime(Channels, N_pixel, W, R, plot=False):

    L = int(W/R)
    Amplitude = []
    Inter_time = []
    t0 = 0

    if N_pixel > 1:
        for i in range(N_pixel):
            for j in range(L):
                if Channels[i,j] > Channels[i,j-1] and Channels[i,j] > Channels[i,j+1]:
                    Amplitude.append(Channels[i,j])
                    Inter_time.append(j*R*1e-9 - t0)
                    t0 = j*R*1e-9
            t0 = 0
    else:
        for j in range(L):
            if Channels[j] > Channels[j-1] and Channels[j] > Channels[j+1]:
                Amplitude.append(Channels[j])
                Inter_time.append(j*R*1e-9 - t0)
                t0 = j*R*1e-9
        t0 = 0
        
    if plot==True:
        
        plt.figure(figsize=(6, 4))
        plt.semilogx(Inter_time, Amplitude, ls=' ', marker='o', color='seagreen', alpha=0.2)
        plt.xlabel("Inter-time [s]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Amplitude [pe]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
        bins, edges = np.histogram(np.log10(np.array(Inter_time)),50)
        left, right = edges[:-1], edges[1:]
        X = np.array([left, right]).T.flatten()
        Y = np.array([bins, bins]).T.flatten()

        plt.figure(figsize=(6, 4))
        plt.loglog(10**X, Y,'b')
        plt.xlabel("Inter-time [s]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Counts", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
        bins, edges = np.histogram(Amplitude,295)
        left, right = edges[:-1], edges[1:]
        X = np.array([left, right]).T.flatten()
        Y = np.array([bins, bins]).T.flatten()

        plt.figure(figsize=(6, 4))
        plt.semilogy(X, Y,'k')
        plt.xlabel("Amplitude [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("Counts", horizontalalignment='right', y=1.0, fontsize=15)
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.show()
        
    return Amplitude, Inter_time, X, Y

# DCR vs. threshold

def DCR_threshold(Channel, W, R, Lt, Ht, samples, plot=False):
    
    Threshold = np.linspace(Lt,Ht,samples)
    M = len(Threshold)
    DCR_MPPC = np.zeros(M)
    count = 0
    L = int(W/R)

    for i in range(M):
        for j in range(L):
            if Channel[j]>= Threshold[i] and Channel[j] > Channel[j-1] and Channel[j] > Channel[j+1]:
                count += 1
        DCR_MPPC[i]=count/(W*1e-9)
        count = 0
        
    if plot==True:
        plt.figure(figsize=(8, 6))
        plt.semilogy(Threshold, DCR_MPPC, 'k', label='model')
        plt.xlabel("Threshold [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("DCR [Hz]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.axvline(0.5, color='r')
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.grid()
        plt.show()

    return DCR_MPPC, Threshold

# DCR vs. threshold using data

def DCR_threshold_data(Channel, W, R, Threshold, plot=False):
    
    M = len(Threshold)
    DCR_MPPC = np.zeros(M)
    count = 0
    L = int(W/R)

    for i in range(M):
        for j in range(L):
            if Channel[j]>= Threshold[i] and Channel[j] > Channel[j-1] and Channel[j] > Channel[j+1]:
                count += 1
        DCR_MPPC[i]=count/(W*1e-9)
        count = 0
        
    if plot==True:
        plt.figure(figsize=(8, 6))
        plt.semilogy(Threshold, DCR_MPPC, 'k', label='model')
        plt.xlabel("Threshold [spe]", horizontalalignment='right', x=1.0, fontsize=15)
        plt.ylabel("DCR [Hz]", horizontalalignment='right', y=1.0, fontsize=15)
        plt.axvline(0.5, color='r')
        plt.xticks(fontsize=15)
        plt.yticks(fontsize=15)
        plt.grid()
        plt.show()

    return DCR_MPPC, Threshold

def Camera_noise(Pulse_shape, N_pixel, Pixel_size, M, DCR, Cross, After, Tau_rec, Tau_AP, W, R, sigma, Nr, Nc, t0, Window, Th ):

    Array_i = np.zeros((N_pixel,W))
    P = Nr*Nc # Number of MPPC (rows x columns)

    Noise_array = np.zeros((Nr*M,Nc*M))

    fig = plt.figure(figsize=(5, 5))

    C = 0
    F = 0

    # Triggering parameters

    Trigger = Th*np.max(Pulse_shape)

    A = Nc if Nc>Nr else Nr
    fig = plt.figure(figsize=(A,A))
    
    for j in range(P):
        Array_i, time = MPPC(Pulse_shape, N_pixel, DCR, Pixel_size, Cross, After, Tau_rec, Tau_AP, W, R, sigma)

        MPPC_i = np.zeros(N_pixel) 

        for i in range(N_pixel):
            if np.max(Array_i[i,t0:t0+Window]) >= Trigger:
                MPPC_i[i] = 1
        MPPC_data = np.reshape(MPPC_i, (M, M))
        Noise_array[F*M+0:F*M+M,C*M+0:C*M+M] = MPPC_data 
        C+=1
        if C==P/Nr:
            C=0
            F+=1

        plt.subplot(A,A,j+1)
        plt.imshow(MPPC_data, cmap='Blues')
        plt.xticks([])
        plt.yticks([])
        fig.tight_layout(pad=0.01)
        
    return Noise_array


def Ring_generator(Nr, Nc, r, M, Np_ring, N_rings):

    Ring_array = np.zeros((Nc*M,Nr*M))

    for j in range(N_rings):

        x0 = int(np.random.uniform(0, Nc*M))
        y0 = int(np.random.uniform(0, Nr*M))

        for i in range(Np_ring):

            theta = np.random.uniform(0, 2*np.pi)

            x = int(r*np.cos(theta))
            y = int(r*np.sin(theta))
            a = x + x0
            b = y + y0

            if a >= 0 and b >=0 and a < Nc*M and b < Nr*M: # boundary conditions
                Ring_array[a,b]= Ring_array[a,b] + 1
                
    return Ring_array


def Shower_generator(Nr, Nc, M, Np_shower, cov):
    
    Shower_array = np.zeros((Nc*M,Nr*M))
    
    x0 = int(np.random.uniform(0, Nc*M))
    y0 = int(np.random.uniform(0, Nr*M))
    
    pts = np.random.multivariate_normal([x0, y0], cov, Np_shower)
    
    for i in range(Np_shower):
    
            a = int(pts[i, 0])
            b = int(pts[i, 1])
    
            if a >= 0 and b >=0 and a < Nc*M and b < Nr*M: # boundary conditions
                Shower_array[a,b]= Shower_array[a,b] + 1
                
    return Shower_array
    

def Camera_plot(signal, noise, M, Nr, Nc, cmap='viridis', lc='w'):
    Event =  signal.T + noise
    
    plt.imshow(Event, cmap=cmap)
    
    for i in range(Nc):
            plt.axvline((i)*M-0.5, color=lc, lw=0.5, ls='dotted')
    for i in range(Nr):
            plt.axhline((i)*M-0.5, color=lc, lw=0.5, ls='dotted')
    
    plt.xticks([])
    plt.yticks([])
    
    plt.colorbar(label='Photoelectrons')

def voting_trigger(signal, noise, M, Nr, Nc, L0_threshold, cmap='viridis'):

    Event =  signal.T + noise

    L0_trigger = np.zeros((Nr, Nc))
    P_signal = 0
    P_noise = 0
    B_signal = 0
    B_noise = 0
    
    for i in range(Nr):
        for j in range(Nc):
            if np.sum(Event[i*M:i*M+M,j*M:j*M+M]) >= L0_threshold:
                L0_trigger[i,j] = 1
            if np.sum(signal[i*M:i*M+M,j*M:j*M+M]) >= L0_threshold:
                P_signal += 1
            if np.sum(signal[i*M:i*M+M,j*M:j*M+M]) != 0:
                B_signal += 1
            if np.sum(noise[i*M:i*M+M,j*M:j*M+M]) >= L0_threshold:
                P_noise += 1
            if np.sum(noise[i*M:i*M+M,j*M:j*M+M]) != 0:
                B_noise += 1

    print ("Signal %f" % (P_signal/B_signal))
    print ("Noise %f" % (P_noise/B_noise))

    plt.imshow(L0_trigger, cmap=cmap)
    plt.title("L0 trigger", fontsize=15)
    plt.xticks([])
    plt.yticks([])

    return L0_trigger